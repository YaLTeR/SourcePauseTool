// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_FCPS_FB_FCPS_H_
#define FLATBUFFERS_GENERATED_FCPS_FB_FCPS_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

#include "ent_generated.h"
#include "mesh_generated.h"

namespace fb {
namespace fcps {

struct FcpsEntMesh;
struct FcpsEntMeshBuilder;

struct FcpsEntInfo;
struct FcpsEntInfoBuilder;

struct FcpsCompactRay;

struct FcpsTraceResult;

struct FcpsNudgeIteration;
struct FcpsNudgeIterationBuilder;

struct FcpsEvent;
struct FcpsEventBuilder;

struct FcpsEventList;
struct FcpsEventListBuilder;

enum class FcpsCaller : uint8_t {
  UNKNOWN = 0,
  VPhysicsShadowUpdate = 1,
  RemoveEntityFromPortalHole = 2,
  CheckStuck = 3,
  TeleportTouchingEntity = 4,
  PortalSimulator__MoveTo = 5,
  Debug_FixMyPosition = 6,
  MIN = UNKNOWN,
  MAX = Debug_FixMyPosition
};

inline const FcpsCaller (&EnumValuesFcpsCaller())[7] {
  static const FcpsCaller values[] = {
    FcpsCaller::UNKNOWN,
    FcpsCaller::VPhysicsShadowUpdate,
    FcpsCaller::RemoveEntityFromPortalHole,
    FcpsCaller::CheckStuck,
    FcpsCaller::TeleportTouchingEntity,
    FcpsCaller::PortalSimulator__MoveTo,
    FcpsCaller::Debug_FixMyPosition
  };
  return values;
}

inline const char * const *EnumNamesFcpsCaller() {
  static const char * const names[8] = {
    "UNKNOWN",
    "VPhysicsShadowUpdate",
    "RemoveEntityFromPortalHole",
    "CheckStuck",
    "TeleportTouchingEntity",
    "PortalSimulator__MoveTo",
    "Debug_FixMyPosition",
    nullptr
  };
  return names;
}

inline const char *EnumNameFcpsCaller(FcpsCaller e) {
  if (::flatbuffers::IsOutRange(e, FcpsCaller::UNKNOWN, FcpsCaller::Debug_FixMyPosition)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFcpsCaller()[index];
}

/// you should only ever see SUCCESS/FAIL - the other results should not be serialized or saved to the queue
enum class FcpsCallResult : uint8_t {
  IMPLEMENTAION_INCOMPLETE = 0,
  SUCCESS = 1,
  FAIL = 2,
  NOT_RUN_CVAR_DISABLED = 3,
  NOT_RUN_HAS_MOVE_PARENT = 4,
  MIN = IMPLEMENTAION_INCOMPLETE,
  MAX = NOT_RUN_HAS_MOVE_PARENT
};

inline const FcpsCallResult (&EnumValuesFcpsCallResult())[5] {
  static const FcpsCallResult values[] = {
    FcpsCallResult::IMPLEMENTAION_INCOMPLETE,
    FcpsCallResult::SUCCESS,
    FcpsCallResult::FAIL,
    FcpsCallResult::NOT_RUN_CVAR_DISABLED,
    FcpsCallResult::NOT_RUN_HAS_MOVE_PARENT
  };
  return values;
}

inline const char * const *EnumNamesFcpsCallResult() {
  static const char * const names[6] = {
    "IMPLEMENTAION_INCOMPLETE",
    "SUCCESS",
    "FAIL",
    "NOT_RUN_CVAR_DISABLED",
    "NOT_RUN_HAS_MOVE_PARENT",
    nullptr
  };
  return names;
}

inline const char *EnumNameFcpsCallResult(FcpsCallResult e) {
  if (::flatbuffers::IsOutRange(e, FcpsCallResult::IMPLEMENTAION_INCOMPLETE, FcpsCallResult::NOT_RUN_HAS_MOVE_PARENT)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFcpsCallResult()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) FcpsCompactRay FLATBUFFERS_FINAL_CLASS {
 private:
  fb::math::Vector3 start_;
  fb::math::Vector3 delta_;
  fb::math::Vector3 extents_;

 public:
  struct Traits;
  FcpsCompactRay()
      : start_(),
        delta_(),
        extents_() {
  }
  FcpsCompactRay(const fb::math::Vector3 &_start, const fb::math::Vector3 &_delta, const fb::math::Vector3 &_extents)
      : start_(_start),
        delta_(_delta),
        extents_(_extents) {
  }
  const fb::math::Vector3 &start() const {
    return start_;
  }
  const fb::math::Vector3 &delta() const {
    return delta_;
  }
  const fb::math::Vector3 &extents() const {
    return extents_;
  }
};
FLATBUFFERS_STRUCT_END(FcpsCompactRay, 36);

struct FcpsCompactRay::Traits {
  using type = FcpsCompactRay;
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) FcpsTraceResult FLATBUFFERS_FINAL_CLASS {
 private:
  fb::fcps::FcpsCompactRay ray_;
  fb::ent::CBaseTrace trace_;
  uint32_t hit_ent_idx_;

 public:
  struct Traits;
  FcpsTraceResult()
      : ray_(),
        trace_(),
        hit_ent_idx_(0) {
  }
  FcpsTraceResult(const fb::fcps::FcpsCompactRay &_ray, const fb::ent::CBaseTrace &_trace, uint32_t _hit_ent_idx)
      : ray_(_ray),
        trace_(_trace),
        hit_ent_idx_(::flatbuffers::EndianScalar(_hit_ent_idx)) {
  }
  const fb::fcps::FcpsCompactRay &ray() const {
    return ray_;
  }
  const fb::ent::CBaseTrace &trace() const {
    return trace_;
  }
  uint32_t hit_ent_idx() const {
    return ::flatbuffers::EndianScalar(hit_ent_idx_);
  }
};
FLATBUFFERS_STRUCT_END(FcpsTraceResult, 92);

struct FcpsTraceResult::Traits {
  using type = FcpsTraceResult;
};

struct FcpsEntMesh FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FcpsEntMeshBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BALL_RADIUS = 4,
    VT_TRANSFORM = 6,
    VT_PHYS_MESH = 8
  };
  float ball_radius() const {
    return GetField<float>(VT_BALL_RADIUS, 0.0f);
  }
  /// transform is in world space
  const fb::math::Transform *transform() const {
    return GetStruct<const fb::math::Transform *>(VT_TRANSFORM);
  }
  const fb::mesh::MbCompactMesh *phys_mesh() const {
    return GetPointer<const fb::mesh::MbCompactMesh *>(VT_PHYS_MESH);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_BALL_RADIUS, 4) &&
           VerifyField<fb::math::Transform>(verifier, VT_TRANSFORM, 4) &&
           VerifyOffset(verifier, VT_PHYS_MESH) &&
           verifier.VerifyTable(phys_mesh()) &&
           verifier.EndTable();
  }
};

struct FcpsEntMeshBuilder {
  typedef FcpsEntMesh Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ball_radius(float ball_radius) {
    fbb_.AddElement<float>(FcpsEntMesh::VT_BALL_RADIUS, ball_radius, 0.0f);
  }
  void add_transform(const fb::math::Transform *transform) {
    fbb_.AddStruct(FcpsEntMesh::VT_TRANSFORM, transform);
  }
  void add_phys_mesh(::flatbuffers::Offset<fb::mesh::MbCompactMesh> phys_mesh) {
    fbb_.AddOffset(FcpsEntMesh::VT_PHYS_MESH, phys_mesh);
  }
  explicit FcpsEntMeshBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FcpsEntMesh> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FcpsEntMesh>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FcpsEntMesh> CreateFcpsEntMesh(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float ball_radius = 0.0f,
    const fb::math::Transform *transform = nullptr,
    ::flatbuffers::Offset<fb::mesh::MbCompactMesh> phys_mesh = 0) {
  FcpsEntMeshBuilder builder_(_fbb);
  builder_.add_phys_mesh(phys_mesh);
  builder_.add_transform(transform);
  builder_.add_ball_radius(ball_radius);
  return builder_.Finish();
}

struct FcpsEntMesh::Traits {
  using type = FcpsEntMesh;
  static auto constexpr Create = CreateFcpsEntMesh;
};

struct FcpsEntInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FcpsEntInfoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HANDLE = 4,
    VT_NET_CLASS_NAME = 6,
    VT_NAME = 8,
    VT_TRANSFORM = 10,
    VT_OBB = 12,
    VT_MESHES = 14
  };
  const fb::ent::CBaseHandle *handle() const {
    return GetStruct<const fb::ent::CBaseHandle *>(VT_HANDLE);
  }
  const ::flatbuffers::String *net_class_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NET_CLASS_NAME);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// entity origin in world space
  const fb::math::Transform *transform() const {
    return GetStruct<const fb::math::Transform *>(VT_TRANSFORM);
  }
  /// OBB is relative to entity origin
  const fb::math::Aabb *obb() const {
    return GetStruct<const fb::math::Aabb *>(VT_OBB);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::fcps::FcpsEntMesh>> *meshes() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::fcps::FcpsEntMesh>> *>(VT_MESHES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<fb::ent::CBaseHandle>(verifier, VT_HANDLE, 4) &&
           VerifyOffset(verifier, VT_NET_CLASS_NAME) &&
           verifier.VerifyString(net_class_name()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<fb::math::Transform>(verifier, VT_TRANSFORM, 4) &&
           VerifyField<fb::math::Aabb>(verifier, VT_OBB, 4) &&
           VerifyOffset(verifier, VT_MESHES) &&
           verifier.VerifyVector(meshes()) &&
           verifier.VerifyVectorOfTables(meshes()) &&
           verifier.EndTable();
  }
};

struct FcpsEntInfoBuilder {
  typedef FcpsEntInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_handle(const fb::ent::CBaseHandle *handle) {
    fbb_.AddStruct(FcpsEntInfo::VT_HANDLE, handle);
  }
  void add_net_class_name(::flatbuffers::Offset<::flatbuffers::String> net_class_name) {
    fbb_.AddOffset(FcpsEntInfo::VT_NET_CLASS_NAME, net_class_name);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(FcpsEntInfo::VT_NAME, name);
  }
  void add_transform(const fb::math::Transform *transform) {
    fbb_.AddStruct(FcpsEntInfo::VT_TRANSFORM, transform);
  }
  void add_obb(const fb::math::Aabb *obb) {
    fbb_.AddStruct(FcpsEntInfo::VT_OBB, obb);
  }
  void add_meshes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::fcps::FcpsEntMesh>>> meshes) {
    fbb_.AddOffset(FcpsEntInfo::VT_MESHES, meshes);
  }
  explicit FcpsEntInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FcpsEntInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FcpsEntInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FcpsEntInfo> CreateFcpsEntInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const fb::ent::CBaseHandle *handle = nullptr,
    ::flatbuffers::Offset<::flatbuffers::String> net_class_name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    const fb::math::Transform *transform = nullptr,
    const fb::math::Aabb *obb = nullptr,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::fcps::FcpsEntMesh>>> meshes = 0) {
  FcpsEntInfoBuilder builder_(_fbb);
  builder_.add_meshes(meshes);
  builder_.add_obb(obb);
  builder_.add_transform(transform);
  builder_.add_name(name);
  builder_.add_net_class_name(net_class_name);
  builder_.add_handle(handle);
  return builder_.Finish();
}

struct FcpsEntInfo::Traits {
  using type = FcpsEntInfo;
  static auto constexpr Create = CreateFcpsEntInfo;
};

inline ::flatbuffers::Offset<FcpsEntInfo> CreateFcpsEntInfoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const fb::ent::CBaseHandle *handle = nullptr,
    const char *net_class_name = nullptr,
    const char *name = nullptr,
    const fb::math::Transform *transform = nullptr,
    const fb::math::Aabb *obb = nullptr,
    const std::vector<::flatbuffers::Offset<fb::fcps::FcpsEntMesh>> *meshes = nullptr) {
  auto net_class_name__ = net_class_name ? _fbb.CreateSharedString(net_class_name) : 0;
  auto name__ = name ? _fbb.CreateSharedString(name) : 0;
  auto meshes__ = meshes ? _fbb.CreateVector<::flatbuffers::Offset<fb::fcps::FcpsEntMesh>>(*meshes) : 0;
  return fb::fcps::CreateFcpsEntInfo(
      _fbb,
      handle,
      net_class_name__,
      name__,
      transform,
      obb,
      meshes__);
}

struct FcpsNudgeIteration FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FcpsNudgeIterationBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CORNER_OOB_BITS = 4,
    VT_TEST_EXTENTS = 6,
    VT_TEST_TRACES = 8,
    VT_TEST_TRACE_CORNER_BITS = 10,
    VT_CORNER_WEIGHTS = 12,
    VT_NUDGE_VEC = 14
  };
  /// one bit for each corner - is it OOB based on PointInsideWorld?
  uint8_t corner_oob_bits() const {
    return GetField<uint8_t>(VT_CORNER_OOB_BITS, 0);
  }
  /// AABB extents on this iteration relative to the entity center
  const fb::math::Vector3 *test_extents() const {
    return GetStruct<const fb::math::Vector3 *>(VT_TEST_EXTENTS);
  }
  /// test traces from inbounds corners to all other corners
  const ::flatbuffers::Vector<const fb::fcps::FcpsTraceResult *> *test_traces() const {
    return GetPointer<const ::flatbuffers::Vector<const fb::fcps::FcpsTraceResult *> *>(VT_TEST_TRACES);
  }
  /// corresponding entires for test_traces, bits 0b00000111 are the source corner, bits 0b00111000 are the desitnation corner
  const ::flatbuffers::Vector<uint8_t> *test_trace_corner_bits() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_TEST_TRACE_CORNER_BITS);
  }
  /// always exactly 8 of these
  const ::flatbuffers::Vector<float> *corner_weights() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_CORNER_WEIGHTS);
  }
  /// in what direction the entity what nudged on this iteration
  const fb::math::Vector3 *nudge_vec() const {
    return GetStruct<const fb::math::Vector3 *>(VT_NUDGE_VEC);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_CORNER_OOB_BITS, 1) &&
           VerifyField<fb::math::Vector3>(verifier, VT_TEST_EXTENTS, 4) &&
           VerifyOffset(verifier, VT_TEST_TRACES) &&
           verifier.VerifyVector(test_traces()) &&
           VerifyOffset(verifier, VT_TEST_TRACE_CORNER_BITS) &&
           verifier.VerifyVector(test_trace_corner_bits()) &&
           VerifyOffset(verifier, VT_CORNER_WEIGHTS) &&
           verifier.VerifyVector(corner_weights()) &&
           VerifyField<fb::math::Vector3>(verifier, VT_NUDGE_VEC, 4) &&
           verifier.EndTable();
  }
};

struct FcpsNudgeIterationBuilder {
  typedef FcpsNudgeIteration Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_corner_oob_bits(uint8_t corner_oob_bits) {
    fbb_.AddElement<uint8_t>(FcpsNudgeIteration::VT_CORNER_OOB_BITS, corner_oob_bits, 0);
  }
  void add_test_extents(const fb::math::Vector3 *test_extents) {
    fbb_.AddStruct(FcpsNudgeIteration::VT_TEST_EXTENTS, test_extents);
  }
  void add_test_traces(::flatbuffers::Offset<::flatbuffers::Vector<const fb::fcps::FcpsTraceResult *>> test_traces) {
    fbb_.AddOffset(FcpsNudgeIteration::VT_TEST_TRACES, test_traces);
  }
  void add_test_trace_corner_bits(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> test_trace_corner_bits) {
    fbb_.AddOffset(FcpsNudgeIteration::VT_TEST_TRACE_CORNER_BITS, test_trace_corner_bits);
  }
  void add_corner_weights(::flatbuffers::Offset<::flatbuffers::Vector<float>> corner_weights) {
    fbb_.AddOffset(FcpsNudgeIteration::VT_CORNER_WEIGHTS, corner_weights);
  }
  void add_nudge_vec(const fb::math::Vector3 *nudge_vec) {
    fbb_.AddStruct(FcpsNudgeIteration::VT_NUDGE_VEC, nudge_vec);
  }
  explicit FcpsNudgeIterationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FcpsNudgeIteration> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FcpsNudgeIteration>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FcpsNudgeIteration> CreateFcpsNudgeIteration(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t corner_oob_bits = 0,
    const fb::math::Vector3 *test_extents = nullptr,
    ::flatbuffers::Offset<::flatbuffers::Vector<const fb::fcps::FcpsTraceResult *>> test_traces = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> test_trace_corner_bits = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> corner_weights = 0,
    const fb::math::Vector3 *nudge_vec = nullptr) {
  FcpsNudgeIterationBuilder builder_(_fbb);
  builder_.add_nudge_vec(nudge_vec);
  builder_.add_corner_weights(corner_weights);
  builder_.add_test_trace_corner_bits(test_trace_corner_bits);
  builder_.add_test_traces(test_traces);
  builder_.add_test_extents(test_extents);
  builder_.add_corner_oob_bits(corner_oob_bits);
  return builder_.Finish();
}

struct FcpsNudgeIteration::Traits {
  using type = FcpsNudgeIteration;
  static auto constexpr Create = CreateFcpsNudgeIteration;
};

inline ::flatbuffers::Offset<FcpsNudgeIteration> CreateFcpsNudgeIterationDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t corner_oob_bits = 0,
    const fb::math::Vector3 *test_extents = nullptr,
    const std::vector<fb::fcps::FcpsTraceResult> *test_traces = nullptr,
    const std::vector<uint8_t> *test_trace_corner_bits = nullptr,
    const std::vector<float> *corner_weights = nullptr,
    const fb::math::Vector3 *nudge_vec = nullptr) {
  auto test_traces__ = test_traces ? _fbb.CreateVectorOfStructs<fb::fcps::FcpsTraceResult>(*test_traces) : 0;
  auto test_trace_corner_bits__ = test_trace_corner_bits ? _fbb.CreateVector<uint8_t>(*test_trace_corner_bits) : 0;
  auto corner_weights__ = corner_weights ? _fbb.CreateVector<float>(*corner_weights) : 0;
  return fb::fcps::CreateFcpsNudgeIteration(
      _fbb,
      corner_oob_bits,
      test_extents,
      test_traces__,
      test_trace_corner_bits__,
      corner_weights__,
      nudge_vec);
}

struct FcpsEvent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FcpsEventBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HANDLE = 4,
    VT_INDECISIVE_PUSH = 6,
    VT_F_MASK = 8,
    VT_FUNC_CALLER = 10,
    VT_CALL_RESULT = 12,
    VT_FROM_ORIGIN = 14,
    VT_TO_ORIGIN = 16,
    VT_GAME_VERSION = 18,
    VT_HOST_TICK = 20,
    VT_SERVER_TICK = 22,
    VT_MAP_NAME = 24,
    VT_PLAYER_NAME = 26,
    VT_ENTITIES = 28,
    VT_RUN_ON_ENT = 30,
    VT_COLLISION_GROUP = 32,
    VT_AABB_EXTENTS = 34,
    VT_ENT_CENTER_TO_ORIGIN_DIFF = 36,
    VT_GROW_SIZE = 38,
    VT_RAY_START_MINS = 40,
    VT_RAY_START_MAXS = 42,
    VT_ENT_TRACES = 44,
    VT_NUDGE_ITERATIONS = 46
  };
  const fb::ent::CBaseHandle *handle() const {
    return GetStruct<const fb::ent::CBaseHandle *>(VT_HANDLE);
  }
  const fb::math::Vector3 *indecisive_push() const {
    return GetStruct<const fb::math::Vector3 *>(VT_INDECISIVE_PUSH);
  }
  uint32_t f_mask() const {
    return GetField<uint32_t>(VT_F_MASK, 0);
  }
  fb::fcps::FcpsCaller func_caller() const {
    return static_cast<fb::fcps::FcpsCaller>(GetField<uint8_t>(VT_FUNC_CALLER, 0));
  }
  fb::fcps::FcpsCallResult call_result() const {
    return static_cast<fb::fcps::FcpsCallResult>(GetField<uint8_t>(VT_CALL_RESULT, 0));
  }
  const fb::math::Vector3 *from_origin() const {
    return GetStruct<const fb::math::Vector3 *>(VT_FROM_ORIGIN);
  }
  const fb::math::Vector3 *to_origin() const {
    return GetStruct<const fb::math::Vector3 *>(VT_TO_ORIGIN);
  }
  int32_t game_version() const {
    return GetField<int32_t>(VT_GAME_VERSION, -1);
  }
  int32_t host_tick() const {
    return GetField<int32_t>(VT_HOST_TICK, 0);
  }
  int32_t server_tick() const {
    return GetField<int32_t>(VT_SERVER_TICK, 0);
  }
  const ::flatbuffers::String *map_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MAP_NAME);
  }
  const ::flatbuffers::String *player_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PLAYER_NAME);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::fcps::FcpsEntInfo>> *entities() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::fcps::FcpsEntInfo>> *>(VT_ENTITIES);
  }
  uint32_t run_on_ent() const {
    return GetField<uint32_t>(VT_RUN_ON_ENT, 4294967295);
  }
  int32_t collision_group() const {
    return GetField<int32_t>(VT_COLLISION_GROUP, 0);
  }
  /// relative to entity center
  const fb::math::Vector3 *aabb_extents() const {
    return GetStruct<const fb::math::Vector3 *>(VT_AABB_EXTENTS);
  }
  const fb::math::Vector3 *ent_center_to_origin_diff() const {
    return GetStruct<const fb::math::Vector3 *>(VT_ENT_CENTER_TO_ORIGIN_DIFF);
  }
  const fb::math::Vector3 *grow_size() const {
    return GetStruct<const fb::math::Vector3 *>(VT_GROW_SIZE);
  }
  const fb::math::Vector3 *ray_start_mins() const {
    return GetStruct<const fb::math::Vector3 *>(VT_RAY_START_MINS);
  }
  const fb::math::Vector3 *ray_start_maxs() const {
    return GetStruct<const fb::math::Vector3 *>(VT_RAY_START_MAXS);
  }
  const ::flatbuffers::Vector<const fb::fcps::FcpsTraceResult *> *ent_traces() const {
    return GetPointer<const ::flatbuffers::Vector<const fb::fcps::FcpsTraceResult *> *>(VT_ENT_TRACES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::fcps::FcpsNudgeIteration>> *nudge_iterations() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::fcps::FcpsNudgeIteration>> *>(VT_NUDGE_ITERATIONS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<fb::ent::CBaseHandle>(verifier, VT_HANDLE, 4) &&
           VerifyField<fb::math::Vector3>(verifier, VT_INDECISIVE_PUSH, 4) &&
           VerifyField<uint32_t>(verifier, VT_F_MASK, 4) &&
           VerifyField<uint8_t>(verifier, VT_FUNC_CALLER, 1) &&
           VerifyField<uint8_t>(verifier, VT_CALL_RESULT, 1) &&
           VerifyField<fb::math::Vector3>(verifier, VT_FROM_ORIGIN, 4) &&
           VerifyField<fb::math::Vector3>(verifier, VT_TO_ORIGIN, 4) &&
           VerifyField<int32_t>(verifier, VT_GAME_VERSION, 4) &&
           VerifyField<int32_t>(verifier, VT_HOST_TICK, 4) &&
           VerifyField<int32_t>(verifier, VT_SERVER_TICK, 4) &&
           VerifyOffset(verifier, VT_MAP_NAME) &&
           verifier.VerifyString(map_name()) &&
           VerifyOffset(verifier, VT_PLAYER_NAME) &&
           verifier.VerifyString(player_name()) &&
           VerifyOffset(verifier, VT_ENTITIES) &&
           verifier.VerifyVector(entities()) &&
           verifier.VerifyVectorOfTables(entities()) &&
           VerifyField<uint32_t>(verifier, VT_RUN_ON_ENT, 4) &&
           VerifyField<int32_t>(verifier, VT_COLLISION_GROUP, 4) &&
           VerifyField<fb::math::Vector3>(verifier, VT_AABB_EXTENTS, 4) &&
           VerifyField<fb::math::Vector3>(verifier, VT_ENT_CENTER_TO_ORIGIN_DIFF, 4) &&
           VerifyField<fb::math::Vector3>(verifier, VT_GROW_SIZE, 4) &&
           VerifyField<fb::math::Vector3>(verifier, VT_RAY_START_MINS, 4) &&
           VerifyField<fb::math::Vector3>(verifier, VT_RAY_START_MAXS, 4) &&
           VerifyOffset(verifier, VT_ENT_TRACES) &&
           verifier.VerifyVector(ent_traces()) &&
           VerifyOffset(verifier, VT_NUDGE_ITERATIONS) &&
           verifier.VerifyVector(nudge_iterations()) &&
           verifier.VerifyVectorOfTables(nudge_iterations()) &&
           verifier.EndTable();
  }
};

struct FcpsEventBuilder {
  typedef FcpsEvent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_handle(const fb::ent::CBaseHandle *handle) {
    fbb_.AddStruct(FcpsEvent::VT_HANDLE, handle);
  }
  void add_indecisive_push(const fb::math::Vector3 *indecisive_push) {
    fbb_.AddStruct(FcpsEvent::VT_INDECISIVE_PUSH, indecisive_push);
  }
  void add_f_mask(uint32_t f_mask) {
    fbb_.AddElement<uint32_t>(FcpsEvent::VT_F_MASK, f_mask, 0);
  }
  void add_func_caller(fb::fcps::FcpsCaller func_caller) {
    fbb_.AddElement<uint8_t>(FcpsEvent::VT_FUNC_CALLER, static_cast<uint8_t>(func_caller), 0);
  }
  void add_call_result(fb::fcps::FcpsCallResult call_result) {
    fbb_.AddElement<uint8_t>(FcpsEvent::VT_CALL_RESULT, static_cast<uint8_t>(call_result), 0);
  }
  void add_from_origin(const fb::math::Vector3 *from_origin) {
    fbb_.AddStruct(FcpsEvent::VT_FROM_ORIGIN, from_origin);
  }
  void add_to_origin(const fb::math::Vector3 *to_origin) {
    fbb_.AddStruct(FcpsEvent::VT_TO_ORIGIN, to_origin);
  }
  void add_game_version(int32_t game_version) {
    fbb_.AddElement<int32_t>(FcpsEvent::VT_GAME_VERSION, game_version, -1);
  }
  void add_host_tick(int32_t host_tick) {
    fbb_.AddElement<int32_t>(FcpsEvent::VT_HOST_TICK, host_tick, 0);
  }
  void add_server_tick(int32_t server_tick) {
    fbb_.AddElement<int32_t>(FcpsEvent::VT_SERVER_TICK, server_tick, 0);
  }
  void add_map_name(::flatbuffers::Offset<::flatbuffers::String> map_name) {
    fbb_.AddOffset(FcpsEvent::VT_MAP_NAME, map_name);
  }
  void add_player_name(::flatbuffers::Offset<::flatbuffers::String> player_name) {
    fbb_.AddOffset(FcpsEvent::VT_PLAYER_NAME, player_name);
  }
  void add_entities(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::fcps::FcpsEntInfo>>> entities) {
    fbb_.AddOffset(FcpsEvent::VT_ENTITIES, entities);
  }
  void add_run_on_ent(uint32_t run_on_ent) {
    fbb_.AddElement<uint32_t>(FcpsEvent::VT_RUN_ON_ENT, run_on_ent, 4294967295);
  }
  void add_collision_group(int32_t collision_group) {
    fbb_.AddElement<int32_t>(FcpsEvent::VT_COLLISION_GROUP, collision_group, 0);
  }
  void add_aabb_extents(const fb::math::Vector3 *aabb_extents) {
    fbb_.AddStruct(FcpsEvent::VT_AABB_EXTENTS, aabb_extents);
  }
  void add_ent_center_to_origin_diff(const fb::math::Vector3 *ent_center_to_origin_diff) {
    fbb_.AddStruct(FcpsEvent::VT_ENT_CENTER_TO_ORIGIN_DIFF, ent_center_to_origin_diff);
  }
  void add_grow_size(const fb::math::Vector3 *grow_size) {
    fbb_.AddStruct(FcpsEvent::VT_GROW_SIZE, grow_size);
  }
  void add_ray_start_mins(const fb::math::Vector3 *ray_start_mins) {
    fbb_.AddStruct(FcpsEvent::VT_RAY_START_MINS, ray_start_mins);
  }
  void add_ray_start_maxs(const fb::math::Vector3 *ray_start_maxs) {
    fbb_.AddStruct(FcpsEvent::VT_RAY_START_MAXS, ray_start_maxs);
  }
  void add_ent_traces(::flatbuffers::Offset<::flatbuffers::Vector<const fb::fcps::FcpsTraceResult *>> ent_traces) {
    fbb_.AddOffset(FcpsEvent::VT_ENT_TRACES, ent_traces);
  }
  void add_nudge_iterations(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::fcps::FcpsNudgeIteration>>> nudge_iterations) {
    fbb_.AddOffset(FcpsEvent::VT_NUDGE_ITERATIONS, nudge_iterations);
  }
  explicit FcpsEventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FcpsEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FcpsEvent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FcpsEvent> CreateFcpsEvent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const fb::ent::CBaseHandle *handle = nullptr,
    const fb::math::Vector3 *indecisive_push = nullptr,
    uint32_t f_mask = 0,
    fb::fcps::FcpsCaller func_caller = fb::fcps::FcpsCaller::UNKNOWN,
    fb::fcps::FcpsCallResult call_result = fb::fcps::FcpsCallResult::IMPLEMENTAION_INCOMPLETE,
    const fb::math::Vector3 *from_origin = nullptr,
    const fb::math::Vector3 *to_origin = nullptr,
    int32_t game_version = -1,
    int32_t host_tick = 0,
    int32_t server_tick = 0,
    ::flatbuffers::Offset<::flatbuffers::String> map_name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> player_name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::fcps::FcpsEntInfo>>> entities = 0,
    uint32_t run_on_ent = 4294967295,
    int32_t collision_group = 0,
    const fb::math::Vector3 *aabb_extents = nullptr,
    const fb::math::Vector3 *ent_center_to_origin_diff = nullptr,
    const fb::math::Vector3 *grow_size = nullptr,
    const fb::math::Vector3 *ray_start_mins = nullptr,
    const fb::math::Vector3 *ray_start_maxs = nullptr,
    ::flatbuffers::Offset<::flatbuffers::Vector<const fb::fcps::FcpsTraceResult *>> ent_traces = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::fcps::FcpsNudgeIteration>>> nudge_iterations = 0) {
  FcpsEventBuilder builder_(_fbb);
  builder_.add_nudge_iterations(nudge_iterations);
  builder_.add_ent_traces(ent_traces);
  builder_.add_ray_start_maxs(ray_start_maxs);
  builder_.add_ray_start_mins(ray_start_mins);
  builder_.add_grow_size(grow_size);
  builder_.add_ent_center_to_origin_diff(ent_center_to_origin_diff);
  builder_.add_aabb_extents(aabb_extents);
  builder_.add_collision_group(collision_group);
  builder_.add_run_on_ent(run_on_ent);
  builder_.add_entities(entities);
  builder_.add_player_name(player_name);
  builder_.add_map_name(map_name);
  builder_.add_server_tick(server_tick);
  builder_.add_host_tick(host_tick);
  builder_.add_game_version(game_version);
  builder_.add_to_origin(to_origin);
  builder_.add_from_origin(from_origin);
  builder_.add_f_mask(f_mask);
  builder_.add_indecisive_push(indecisive_push);
  builder_.add_handle(handle);
  builder_.add_call_result(call_result);
  builder_.add_func_caller(func_caller);
  return builder_.Finish();
}

struct FcpsEvent::Traits {
  using type = FcpsEvent;
  static auto constexpr Create = CreateFcpsEvent;
};

inline ::flatbuffers::Offset<FcpsEvent> CreateFcpsEventDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const fb::ent::CBaseHandle *handle = nullptr,
    const fb::math::Vector3 *indecisive_push = nullptr,
    uint32_t f_mask = 0,
    fb::fcps::FcpsCaller func_caller = fb::fcps::FcpsCaller::UNKNOWN,
    fb::fcps::FcpsCallResult call_result = fb::fcps::FcpsCallResult::IMPLEMENTAION_INCOMPLETE,
    const fb::math::Vector3 *from_origin = nullptr,
    const fb::math::Vector3 *to_origin = nullptr,
    int32_t game_version = -1,
    int32_t host_tick = 0,
    int32_t server_tick = 0,
    const char *map_name = nullptr,
    const char *player_name = nullptr,
    const std::vector<::flatbuffers::Offset<fb::fcps::FcpsEntInfo>> *entities = nullptr,
    uint32_t run_on_ent = 4294967295,
    int32_t collision_group = 0,
    const fb::math::Vector3 *aabb_extents = nullptr,
    const fb::math::Vector3 *ent_center_to_origin_diff = nullptr,
    const fb::math::Vector3 *grow_size = nullptr,
    const fb::math::Vector3 *ray_start_mins = nullptr,
    const fb::math::Vector3 *ray_start_maxs = nullptr,
    const std::vector<fb::fcps::FcpsTraceResult> *ent_traces = nullptr,
    const std::vector<::flatbuffers::Offset<fb::fcps::FcpsNudgeIteration>> *nudge_iterations = nullptr) {
  auto map_name__ = map_name ? _fbb.CreateSharedString(map_name) : 0;
  auto player_name__ = player_name ? _fbb.CreateSharedString(player_name) : 0;
  auto entities__ = entities ? _fbb.CreateVector<::flatbuffers::Offset<fb::fcps::FcpsEntInfo>>(*entities) : 0;
  auto ent_traces__ = ent_traces ? _fbb.CreateVectorOfStructs<fb::fcps::FcpsTraceResult>(*ent_traces) : 0;
  auto nudge_iterations__ = nudge_iterations ? _fbb.CreateVector<::flatbuffers::Offset<fb::fcps::FcpsNudgeIteration>>(*nudge_iterations) : 0;
  return fb::fcps::CreateFcpsEvent(
      _fbb,
      handle,
      indecisive_push,
      f_mask,
      func_caller,
      call_result,
      from_origin,
      to_origin,
      game_version,
      host_tick,
      server_tick,
      map_name__,
      player_name__,
      entities__,
      run_on_ent,
      collision_group,
      aabb_extents,
      ent_center_to_origin_diff,
      grow_size,
      ray_start_mins,
      ray_start_maxs,
      ent_traces__,
      nudge_iterations__);
}

struct FcpsEventList FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FcpsEventListBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EVENTS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<fb::fcps::FcpsEvent>> *events() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fb::fcps::FcpsEvent>> *>(VT_EVENTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_EVENTS) &&
           verifier.VerifyVector(events()) &&
           verifier.VerifyVectorOfTables(events()) &&
           verifier.EndTable();
  }
};

struct FcpsEventListBuilder {
  typedef FcpsEventList Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_events(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::fcps::FcpsEvent>>> events) {
    fbb_.AddOffset(FcpsEventList::VT_EVENTS, events);
  }
  explicit FcpsEventListBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FcpsEventList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FcpsEventList>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FcpsEventList> CreateFcpsEventList(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fb::fcps::FcpsEvent>>> events = 0) {
  FcpsEventListBuilder builder_(_fbb);
  builder_.add_events(events);
  return builder_.Finish();
}

struct FcpsEventList::Traits {
  using type = FcpsEventList;
  static auto constexpr Create = CreateFcpsEventList;
};

inline ::flatbuffers::Offset<FcpsEventList> CreateFcpsEventListDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<fb::fcps::FcpsEvent>> *events = nullptr) {
  auto events__ = events ? _fbb.CreateVector<::flatbuffers::Offset<fb::fcps::FcpsEvent>>(*events) : 0;
  return fb::fcps::CreateFcpsEventList(
      _fbb,
      events__);
}

}  // namespace fcps
}  // namespace fb

#endif  // FLATBUFFERS_GENERATED_FCPS_FB_FCPS_H_
