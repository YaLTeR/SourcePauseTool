// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MESHUTILS_FB_MESH_H_
#define FLATBUFFERS_GENERATED_MESHUTILS_FB_MESH_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

#include "math_generated.h"

namespace fb {
namespace mesh {

struct MbCompactMesh;
struct MbCompactMeshBuilder;

struct MbCompactMesh FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MbCompactMeshBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POINTS = 4,
    VT_COLORS = 6,
    VT_FACE_INDICES = 8,
    VT_LINE_INDICES = 10
  };
  const ::flatbuffers::Vector<const fb::math::Vector3 *> *points() const {
    return GetPointer<const ::flatbuffers::Vector<const fb::math::Vector3 *> *>(VT_POINTS);
  }
  const ::flatbuffers::Vector<const fb::math::Color32 *> *colors() const {
    return GetPointer<const ::flatbuffers::Vector<const fb::math::Color32 *> *>(VT_COLORS);
  }
  const ::flatbuffers::Vector<uint16_t> *face_indices() const {
    return GetPointer<const ::flatbuffers::Vector<uint16_t> *>(VT_FACE_INDICES);
  }
  const ::flatbuffers::Vector<uint16_t> *line_indices() const {
    return GetPointer<const ::flatbuffers::Vector<uint16_t> *>(VT_LINE_INDICES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_POINTS) &&
           verifier.VerifyVector(points()) &&
           VerifyOffset(verifier, VT_COLORS) &&
           verifier.VerifyVector(colors()) &&
           VerifyOffset(verifier, VT_FACE_INDICES) &&
           verifier.VerifyVector(face_indices()) &&
           VerifyOffset(verifier, VT_LINE_INDICES) &&
           verifier.VerifyVector(line_indices()) &&
           verifier.EndTable();
  }
};

struct MbCompactMeshBuilder {
  typedef MbCompactMesh Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_points(::flatbuffers::Offset<::flatbuffers::Vector<const fb::math::Vector3 *>> points) {
    fbb_.AddOffset(MbCompactMesh::VT_POINTS, points);
  }
  void add_colors(::flatbuffers::Offset<::flatbuffers::Vector<const fb::math::Color32 *>> colors) {
    fbb_.AddOffset(MbCompactMesh::VT_COLORS, colors);
  }
  void add_face_indices(::flatbuffers::Offset<::flatbuffers::Vector<uint16_t>> face_indices) {
    fbb_.AddOffset(MbCompactMesh::VT_FACE_INDICES, face_indices);
  }
  void add_line_indices(::flatbuffers::Offset<::flatbuffers::Vector<uint16_t>> line_indices) {
    fbb_.AddOffset(MbCompactMesh::VT_LINE_INDICES, line_indices);
  }
  explicit MbCompactMeshBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MbCompactMesh> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MbCompactMesh>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MbCompactMesh> CreateMbCompactMesh(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<const fb::math::Vector3 *>> points = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const fb::math::Color32 *>> colors = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint16_t>> face_indices = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint16_t>> line_indices = 0) {
  MbCompactMeshBuilder builder_(_fbb);
  builder_.add_line_indices(line_indices);
  builder_.add_face_indices(face_indices);
  builder_.add_colors(colors);
  builder_.add_points(points);
  return builder_.Finish();
}

struct MbCompactMesh::Traits {
  using type = MbCompactMesh;
  static auto constexpr Create = CreateMbCompactMesh;
};

inline ::flatbuffers::Offset<MbCompactMesh> CreateMbCompactMeshDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<fb::math::Vector3> *points = nullptr,
    const std::vector<fb::math::Color32> *colors = nullptr,
    const std::vector<uint16_t> *face_indices = nullptr,
    const std::vector<uint16_t> *line_indices = nullptr) {
  auto points__ = points ? _fbb.CreateVectorOfStructs<fb::math::Vector3>(*points) : 0;
  auto colors__ = colors ? _fbb.CreateVectorOfStructs<fb::math::Color32>(*colors) : 0;
  auto face_indices__ = face_indices ? _fbb.CreateVector<uint16_t>(*face_indices) : 0;
  auto line_indices__ = line_indices ? _fbb.CreateVector<uint16_t>(*line_indices) : 0;
  return fb::mesh::CreateMbCompactMesh(
      _fbb,
      points__,
      colors__,
      face_indices__,
      line_indices__);
}

}  // namespace mesh
}  // namespace fb

#endif  // FLATBUFFERS_GENERATED_MESHUTILS_FB_MESH_H_
